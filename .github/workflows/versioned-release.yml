name: Versioned Documentation Release

on:
  push:
    tags:
      - 'v*.*.*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release (e.g., v2.1.0)'
        required: true
        type: string
      release_type:
        description: 'Type of release'
        required: true
        default: 'minor'
        type: choice
        options:
          - major
          - minor
          - patch
          - prerelease
      prerelease_tag:
        description: 'Prerelease tag (e.g., alpha, beta, rc)'
        required: false
        type: string
      set_as_default:
        description: 'Set as default version'
        required: false
        default: false
        type: boolean
      create_migration_notes:
        description: 'Create migration notes'
        required: false
        default: true
        type: boolean

permissions:
  contents: write
  pages: write
  id-token: write
  pull-requests: write

concurrency:
  group: "versioned-release"
  cancel-in-progress: false

env:
  PYTHON_VERSION: '3.11'
  NODE_VERSION: '18'

jobs:
  validate:
    name: Validate Release
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      version_clean: ${{ steps.version.outputs.version_clean }}
      release_type: ${{ steps.version.outputs.release_type }}
      previous_version: ${{ steps.version.outputs.previous_version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -e .
          pip install -r requirements.txt
          pip install mike packaging GitPython

      - name: Determine version
        id: version
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            VERSION="${{ github.event.inputs.version }}"
            RELEASE_TYPE="${{ github.event.inputs.release_type }}"
          else
            VERSION="${{ github.ref_name }}"
            RELEASE_TYPE="patch"
          fi
          
          # Clean version (remove 'v' prefix)
          VERSION_CLEAN="${VERSION#v}"
          
          # Get previous version
          PREVIOUS_VERSION=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "v0.0.0")
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "version_clean=$VERSION_CLEAN" >> $GITHUB_OUTPUT
          echo "release_type=$RELEASE_TYPE" >> $GITHUB_OUTPUT
          echo "previous_version=$PREVIOUS_VERSION" >> $GITHUB_OUTPUT
          
          echo "Release version: $VERSION"
          echo "Previous version: $PREVIOUS_VERSION"
          echo "Release type: $RELEASE_TYPE"

      - name: Validate version format
        run: |
          python -c "
          from src.csa_docs_tools.version_manager import SemanticVersionManager
          manager = SemanticVersionManager()
          try:
              parsed = manager.parse_version('${{ steps.version.outputs.version }}')
              print(f'Valid version format: {parsed}')
          except ValueError as e:
              print(f'Invalid version format: {e}')
              exit(1)
          "

      - name: Check version doesn't exist
        run: |
          if git tag --list | grep -q "^${{ steps.version.outputs.version }}$"; then
            echo "Version ${{ steps.version.outputs.version }} already exists!"
            exit 1
          fi

      - name: Validate release readiness
        run: |
          python -c "
          from src.csa_docs_tools.release_manager import ReleaseManager
          from pathlib import Path
          
          manager = ReleaseManager(repo_path=Path('.'))
          is_ready, issues = manager.validate_release_readiness('${{ steps.version.outputs.version_clean }}')
          
          if not is_ready:
              print('Release validation failed:')
              for issue in issues:
                  print(f'- {issue}')
              exit(1)
          else:
              print('Release validation passed')
          "

  build:
    name: Build Documentation
    needs: validate
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -e .
          pip install -r requirements.txt
          pip install mike

      - name: Run quality gates
        run: |
          echo "Running quality gates for version ${{ needs.validate.outputs.version }}..."
          
          # Run linting
          python -m ruff check src/
          
          # Run type checking  
          python -m mypy src/
          
          # Run tests
          python -m pytest tests/ -v --cov=src/csa_docs_tools --cov-report=xml
          
          # Validate documentation structure
          python -c "
          from src.csa_docs_tools.navigation_validator import NavigationValidator
          from pathlib import Path
          
          validator = NavigationValidator(Path('.'))
          is_valid, issues = validator.validate_structure()
          
          if not is_valid:
              print('Navigation validation failed:')
              for issue in issues:
                  print(f'- {issue}')
              exit(1)
          print('Navigation validation passed')
          "
          
          # Validate links
          python -c "
          from src.csa_docs_tools.link_validator import LinkValidator
          from pathlib import Path
          import asyncio
          
          async def validate_links():
              validator = LinkValidator(Path('.'))
              is_valid, results = await validator.validate_all_links()
              
              broken_links = [r for r in results if not r.is_valid]
              if broken_links:
                  print(f'Found {len(broken_links)} broken links:')
                  for link in broken_links[:5]:  # Show first 5
                      print(f'- {link.url}: {link.error}')
                  if len(broken_links) > 5:
                      print(f'... and {len(broken_links) - 5} more')
                  exit(1)
              print('Link validation passed')
          
          asyncio.run(validate_links())
          "

      - name: Generate changelog
        run: |
          python -c "
          from src.csa_docs_tools.release_manager import ReleaseManager
          from pathlib import Path
          
          manager = ReleaseManager(repo_path=Path('.'))
          changelog = manager.generate_changelog(
              from_version='${{ needs.validate.outputs.previous_version }}',
              to_version='${{ needs.validate.outputs.version }}'
          )
          
          with open('RELEASE_CHANGELOG.md', 'w') as f:
              f.write(changelog)
          
          print('Generated changelog:')
          print(changelog[:500] + ('...' if len(changelog) > 500 else ''))
          "

      - name: Build documentation
        run: |
          echo "Building documentation for version ${{ needs.validate.outputs.version_clean }}..."
          mkdocs build --clean --strict

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: documentation-${{ needs.validate.outputs.version_clean }}
          path: |
            site/
            RELEASE_CHANGELOG.md
          retention-days: 30

  test_deployment:
    name: Test Deployment
    needs: [validate, build]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: documentation-${{ needs.validate.outputs.version_clean }}
          path: ./

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -e .
          pip install mike

      - name: Test local deployment
        run: |
          echo "Testing local deployment..."
          
          # Test Mike deployment in dry-run mode
          python -c "
          from src.csa_docs_tools.mike_manager import MikeVersionManager
          from pathlib import Path
          
          manager = MikeVersionManager(Path('.'))
          
          # Simulate deployment validation
          version = '${{ needs.validate.outputs.version_clean }}'
          title = 'v${{ needs.validate.outputs.version_clean }}'
          
          print(f'Would deploy version {version} with title {title}')
          
          # Test version comparison if there are existing versions
          try:
              versions = manager.list_versions()
              if versions:
                  latest = versions[0].version
                  comparison = manager.compare_versions(latest, version)
                  print(f'Version comparison with {latest}: {comparison}')
          except Exception as e:
              print(f'No existing versions to compare: {e}')
          "

  deploy:
    name: Deploy Documentation
    needs: [validate, build, test_deployment]
    runs-on: ubuntu-latest
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: documentation-${{ needs.validate.outputs.version_clean }}
          path: ./

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -e .
          pip install mike

      - name: Configure Git
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

      - name: Deploy version with Mike
        id: deploy
        run: |
          VERSION="${{ needs.validate.outputs.version_clean }}"
          TITLE="CSA Documentation v${VERSION}"
          
          # Prepare aliases
          ALIASES=""
          if [ "${{ github.event.inputs.set_as_default }}" = "true" ] || [ "${{ needs.validate.outputs.release_type }}" = "major" ]; then
            ALIASES="latest"
            echo "Setting as default version"
          fi
          
          # Deploy with Mike
          echo "Deploying version $VERSION with title '$TITLE'..."
          
          if [ -n "$ALIASES" ]; then
            mike deploy --push --update-aliases $VERSION $TITLE $ALIASES
            mike set-default --push $VERSION
          else
            mike deploy --push --update-aliases $VERSION $TITLE
          fi
          
          echo "deployment_url=https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/$VERSION/" >> $GITHUB_OUTPUT

      - name: Create version metadata
        run: |
          python -c "
          from src.csa_docs_tools.mike_manager import MikeVersionManager
          from pathlib import Path
          import json
          from datetime import datetime
          
          manager = MikeVersionManager(Path('.'))
          
          # Create version metadata
          metadata = {
              'version': '${{ needs.validate.outputs.version_clean }}',
              'title': 'CSA Documentation v${{ needs.validate.outputs.version_clean }}',
              'release_date': datetime.now().isoformat(),
              'release_type': '${{ needs.validate.outputs.release_type }}',
              'previous_version': '${{ needs.validate.outputs.previous_version }}',
              'is_default': '${{ github.event.inputs.set_as_default }}' == 'true',
              'changelog_path': 'RELEASE_CHANGELOG.md',
              'deployment_url': '${{ steps.deploy.outputs.deployment_url }}'
          }
          
          with open('version_metadata.json', 'w') as f:
              json.dump(metadata, f, indent=2)
          
          print('Created version metadata:')
          print(json.dumps(metadata, indent=2))
          "

      - name: Update versions configuration
        run: |
          python -c "
          from src.csa_docs_tools.version_manager import SemanticVersionManager, VersionInfo, VersionType
          from pathlib import Path
          from datetime import datetime
          
          manager = SemanticVersionManager(Path('.') / 'versions.yml')
          
          # Determine version type
          version = '${{ needs.validate.outputs.version_clean }}'
          if 'alpha' in version or 'beta' in version or 'rc' in version:
              version_type = VersionType.PRERELEASE
          elif 'dev' in version:
              version_type = VersionType.DEVELOPMENT
          else:
              version_type = VersionType.STABLE
          
          # Create version info
          version_info = VersionInfo(
              version=version,
              version_type=version_type,
              title=f'CSA Documentation v{version}',
              aliases=['latest'] if '${{ github.event.inputs.set_as_default }}' == 'true' else [],
              is_default='${{ github.event.inputs.set_as_default }}' == 'true',
              release_date=datetime.now().strftime('%Y-%m-%d'),
              changelog_path='RELEASE_CHANGELOG.md'
          )
          
          manager.add_version(version_info)
          print(f'Added version {version} to configuration')
          "

  create_release:
    name: Create GitHub Release
    needs: [validate, build, deploy]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: documentation-${{ needs.validate.outputs.version_clean }}
          path: ./artifacts/

      - name: Create release notes
        run: |
          VERSION="${{ needs.validate.outputs.version }}"
          
          cat > RELEASE_NOTES.md << 'EOF'
          # Azure CSA Documentation ${{ needs.validate.outputs.version }}
          
          **Release Date**: $(date '+%Y-%m-%d')
          **Release Type**: ${{ needs.validate.outputs.release_type }}
          
          ## 📖 Documentation
          
          This release includes comprehensive documentation for Azure Cloud Scale Analytics services and architecture patterns.
          
          **View Documentation**: [CSA Documentation v${{ needs.validate.outputs.version_clean }}](https://fgarofalo56.github.io/csa-inabox-docs/${{ needs.validate.outputs.version_clean }}/)
          
          ## 📝 What's Changed
          
          EOF
          
          # Append generated changelog
          if [ -f "artifacts/RELEASE_CHANGELOG.md" ]; then
            cat artifacts/RELEASE_CHANGELOG.md >> RELEASE_NOTES.md
          else
            echo "- Documentation updates and improvements" >> RELEASE_NOTES.md
          fi
          
          cat >> RELEASE_NOTES.md << 'EOF'
          
          ## 🔄 Migration
          
          EOF
          
          if [ "${{ github.event.inputs.create_migration_notes }}" = "true" ]; then
            echo "Migration notes from ${{ needs.validate.outputs.previous_version }} to ${{ needs.validate.outputs.version }}:" >> RELEASE_NOTES.md
            echo "- Review the changelog above for any breaking changes" >> RELEASE_NOTES.md
            echo "- Update bookmarks to use the new version URL" >> RELEASE_NOTES.md
            echo "- Check for deprecated features if upgrading from older versions" >> RELEASE_NOTES.md
          else
            echo "No migration notes for this release." >> RELEASE_NOTES.md
          fi
          
          cat >> RELEASE_NOTES.md << 'EOF'
          
          ## 📦 Downloads
          
          - [Documentation Archive (.tar.gz)](../../releases/download/${{ needs.validate.outputs.version }}/csa-docs-${{ needs.validate.outputs.version }}.tar.gz)
          - [Documentation Archive (.zip)](../../releases/download/${{ needs.validate.outputs.version }}/csa-docs-${{ needs.validate.outputs.version }}.zip)
          
          ---
          
          🤖 This release was automatically generated by the CSA Documentation versioning system.
          
          **Full Changelog**: [${{ needs.validate.outputs.previous_version }}...${{ needs.validate.outputs.version }}](../../compare/${{ needs.validate.outputs.previous_version }}...${{ needs.validate.outputs.version }})
          EOF

      - name: Create release archives
        run: |
          cd artifacts/
          
          # Create tar.gz archive
          tar -czf "../csa-docs-${{ needs.validate.outputs.version }}.tar.gz" site/
          
          # Create zip archive
          zip -r "../csa-docs-${{ needs.validate.outputs.version }}.zip" site/
          
          echo "Created release archives"
          ls -la ../*.{tar.gz,zip}

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ needs.validate.outputs.version }}
          name: "Azure CSA Documentation ${{ needs.validate.outputs.version }}"
          body_path: RELEASE_NOTES.md
          draft: false
          prerelease: ${{ contains(needs.validate.outputs.version, 'alpha') || contains(needs.validate.outputs.version, 'beta') || contains(needs.validate.outputs.version, 'rc') }}
          files: |
            csa-docs-${{ needs.validate.outputs.version }}.tar.gz
            csa-docs-${{ needs.validate.outputs.version }}.zip
            artifacts/version_metadata.json
          token: ${{ secrets.GITHUB_TOKEN }}

  post_release:
    name: Post-Release Tasks
    needs: [validate, create_release]
    runs-on: ubuntu-latest
    if: always() && needs.create_release.result == 'success'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -e .

      - name: Archive old versions
        if: needs.validate.outputs.release_type == 'major'
        run: |
          python -c "
          from src.csa_docs_tools.mike_manager import MikeVersionManager
          from pathlib import Path
          
          manager = MikeVersionManager(Path('.'))
          
          # Archive old versions (keep last 5 stable releases)
          try:
              archived = manager.archive_old_versions(keep_count=5, archive_prereleases=True)
              if archived:
                  print(f'Archived old versions: {archived}')
              else:
                  print('No versions to archive')
          except Exception as e:
              print(f'Error archiving versions: {e}')
          "

      - name: Update documentation index
        run: |
          python -c "
          from src.csa_docs_tools.version_navigation import VersionNavigationManager
          from pathlib import Path
          import json
          
          manager = VersionNavigationManager(Path('.'))
          
          # Generate updated version selector data
          selector_data = manager.generate_version_selector_data()
          
          # Save to assets for use in documentation
          assets_dir = Path('docs') / 'assets' / 'data'
          assets_dir.mkdir(parents=True, exist_ok=True)
          
          with open(assets_dir / 'versions.json', 'w') as f:
              json.dump(selector_data, f, indent=2)
          
          print('Updated version selector data')
          "

      - name: Commit version updates
        run: |
          git add .
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "docs: update version metadata after ${{ needs.validate.outputs.version }} release
          
          - Updated versions.yml configuration
          - Updated version selector data
          - Post-release cleanup
          
          🤖 Generated with [Claude Code](https://claude.ai/code)
          
          Co-Authored-By: Claude <noreply@anthropic.com>"
            git push
            echo "Committed version metadata updates"
          fi

      - name: Create success notification
        run: |
          echo "::notice title=Release Successful::Azure CSA Documentation ${{ needs.validate.outputs.version }} has been successfully released and deployed!"
          echo "::notice title=Documentation URL::View at: https://fgarofalo56.github.io/csa-inabox-docs/${{ needs.validate.outputs.version_clean }}/"
          echo "::notice title=Release URL::GitHub Release: https://github.com/${{ github.repository }}/releases/tag/${{ needs.validate.outputs.version }}"
